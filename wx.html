<!DOCTYPE html>
<html lang="en">
<head>
<meta name="google-site-verification" content="P6rqWS7FvCkbQVwIJLtztDsRWp4XSqEZeMLUkLn_MMo" />
<meta charset="UTF-8">
<title>Seamless Map ‚Äì Overlay Tab Left Middle, Info Panel Right Middle</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<style>
html, body { height:100%; width:100%; padding:0; margin:0; }
body { min-height:100dvh; font-family:system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }

/* Dusk/Day world map filters */
body.dusk-mode .world-map {
    filter: brightness(1.08) sepia(0.08) hue-rotate(-13deg) saturate(1.22) contrast(1.09);
    background-color: #7e87c0!important;
}
body.day-mode .world-map {
    filter: brightness(1.13) contrast(1.16) sepia(0.03) hue-rotate(-7deg) saturate(1.25);
    background-color: #daf0ff!important;
}

/* Dusk and day mode related styling only */
body.dusk-mode .weather-panel  { background: #b3b6dbed; color: #263163; }
body.day-mode .weather-panel   { background: #fff; color: #232425; }
body.dusk-mode .overlay-controls { background:#b3b6dbce;}
body.day-mode .overlay-controls { background:#eefdffde; color:#222;}
body.dusk-mode .overlay-controls label,
body.day-mode .overlay-controls label{ color:#23242d;}
body.day-mode .location-marker { background:#ffe; color:#0069cc;}
body.dusk-mode .location-marker { background: #ece8ff; color: #464093;}

/* Layout */
.map-container { position:relative; width:100vw; height:100vh; overflow:hidden; }

.map-viewport {
    width:100vw;
    height:100vh;
    overflow:hidden;
    position:relative;
    touch-action:none;
    cursor: pointer;
}

.map-tiles-wrap {
    width:300vw; height:100vh;
    display:flex; position:absolute; top:0; left:0;
    will-change:transform;
    transition: transform 0.24s cubic-bezier(.68,-0.55,.27,1.55);
}
.map-tiles-wrap.dragging { transition:none; }

.world-map, .overlay-img {
    width:100vw; height:100vh; min-width:100vw; min-height:100vh;
    object-fit:cover; pointer-events:none; user-drag:none; user-select:none;
    position: absolute; left:0; top:0; transition: filter .22s, background-color .2s; z-index: 1;
}
.overlay-img { opacity: 0.7; pointer-events:none; z-index:10; }
.overlay-img.hidden { opacity:0 !important; }

/* SVG overlay for polyline */
#routeSvg {
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    pointer-events:none;
    z-index:120;
}
#routeLine {
    fill:none;
    stroke:#ffbb33;
    stroke-width:3;
    stroke-linejoin:round;
    stroke-linecap:round;
    opacity:0.9;
}

/* Overlay controls */
.overlay-controls {
    position: fixed; left: 0; top: 50%; transform: translateY(-50%);
    z-index: 301; display: flex; flex-direction: column; gap: 6px;
    border-radius: 13px; padding: 8px;
}
.overlay-controls label { font-size:14px; cursor:pointer;}

/* Route details dropdown (expanded) ‚Äì under main bar */
.route-details {
    position:fixed;
    top:52px;
    left:0;
    width:100vw;
    max-height:110px; /* compact (~3 rows) by default */
    overflow:auto;
    z-index:304;
    background:#111828f5;
    color:#f5f7ff;
    padding:4px 6px;
    box-sizing:border-box;
    display:none;
}
.route-details table {
    width:100%;
    border-collapse:collapse;
    font-size:0.82em;
}
.route-details th,
.route-details td {
    padding:3px 4px;
    border-bottom:1px solid #ffffff22;
    text-align:left;
    white-space:nowrap;
}
.route-details th {
    position:sticky;
    top:0;
    background:#111828;
    z-index:1;
}

/* Top buttons (map controls) */
.top-buttons {
    position:absolute; top:0; left:0; width:100vw;
    display:flex; flex-wrap:wrap; gap:6px; z-index:303;
    align-items:center; background:linear-gradient(90deg,#242c3c 82%,#423877 100%);
    padding:7px 5px 4px 5px; box-sizing:border-box;
    font-size:0.98em;
}
.mode-btn, button {
    border-radius:9px;
    border:2px solid #8882;
    cursor:pointer;
    font-weight:600;
    font-size:0.98em;
    padding:6px 10px;
}
#latLonInput, #placeInput {
    min-width:90px;
    width:25vw;
    max-width:150px;
    padding:6px;
    border-radius:7px;
    border:1px solid #aaa;
    color:#222;
    background:#eefdff;
    font-size:0.94em;
}
#cursorLatLon{
    min-width:90px;
    padding:6px 10px;
    border-radius:7px;
    background:#eefdff;
    color:#222;
    font-family:monospace;
    font-size:0.92em;
}

/* Waypoint toggle label in top bar */
.top-waypoints-toggle {
    display:flex;
    align-items:center;
    gap:4px;
    color:#f5f7ff;
    font-size:0.95em;
}

/* Waypoint checkbox size */
#enableWaypointsTop {
    transform:scale(1.1);
    accent-color:#ffbb33;
}

.location-marker {
    position: absolute;
    padding: 2px 4px;
    border-radius: 50%;
    font-size: 18px;
    transform: translate(-50%, -100%);
    border: 0;
    box-shadow: 0 1px 5px #0004;
    z-index: 150;
    background: transparent;
    line-height: 1;
}

#homeBtn { margin-left:auto; }

.weather-panel {
    position: fixed; right: 8px; top: 50%; transform: translateY(-50%);
    min-width: 190px; max-width: 38vw; border-radius: 12px;
    padding: 12px 14px 12px 14px; font-size: 0.94em;
    box-shadow: 0 3px 20px #193e7e88; z-index: 302;
    display: none; word-break: break-word;
}
.weather-panel.active { display: block; }
.weather-panel button { float:right; background:transparent; border: 0; font-size:1.1em; }

/* Bottom forecast bar */
.forecast-bar {
    position: fixed;
    left: 0;
    bottom: 0;
    width: 100vw;
    background: #141829f0;
    color: #f5f7ff;
    z-index: 303;
    box-sizing: border-box;
    padding: 5px 8px 6px 8px;
    font-size: 0.84em;
    display: none; /* hidden by default */
}
.forecast-header {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 4px;
}
.forecast-header select {
    padding: 3px 5px;
    border-radius: 6px;
    border: 1px solid #999;
    font-size: 0.82em;
}
.forecast-header-spacer {
    margin-left: auto;
}
.forecast-hide-btn {
    background: transparent;
    border: 1px solid #ffffff55;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    color: #fff;
    cursor: pointer;
    font-size: 0.9em;
    display: flex;
    align-items: center;
    justify-content: center;
}
.forecast-scroll {
    display: flex;
    overflow-x: auto;
    gap: 4px;
    padding-bottom: 2px;
}
.forecast-item {
    flex: 0 0 auto;
    min-width: 110px;
    padding: 3px 5px;
    border-radius: 8px;
    background: #252b3cff;
    text-align: left;
    box-shadow: 0 1px 4px #0008;
}
.forecast-item-time {
    font-size: 0.76em;
    opacity: 0.82;
    margin-bottom: 2px;
}
.forecast-item-temp {
    font-weight: bold;
    margin-bottom: 1px;
}
.forecast-item-line {
    font-size: 0.76em;
}
.forecast-item-icon {
    font-size: 1.1em;
    margin-right: 4px;
    vertical-align: middle;
}

/* Mobile portrait optimizations */
@media (max-width: 600px) {
  .top-buttons {
    gap:4px;
    padding:5px 4px 3px 4px;
  }
  .mode-btn, button {
    font-size:0.92em;
    padding:5px 7px;
  }
  #placeInput, #latLonInput {
    width:34vw;
    max-width:none;
    font-size:0.85em;
  }
  #cursorLatLon{
    font-size:0.8em;
    padding:4px 6px;
  }
  .overlay-controls {
    padding:5px;
  }
  .overlay-controls label {
    font-size:12px;
  }
  .weather-panel {
    right:4px;
    max-width: 70vw;
    padding:10px 10px 10px 12px;
    font-size:0.86em;
  }
  .forecast-bar {
    font-size:0.8em;
    padding:4px 6px 5px 6px;
  }
  .forecast-item {
    min-width:100px;
  }
}

/* Extra small screens */
@media (max-width: 430px) {
  .top-buttons {
    row-gap:3px;
  }
  #placeInput, #latLonInput {
    width:40vw;
  }
  .mode-btn {
    font-size:0.86em;
  }
}
</style>
</head>
<body class="dusk-mode">

<div class="map-container">
  <div class="map-viewport">
    <div class="map-tiles-wrap" id="tilesWrap" style="background:#111;">
      <svg id="routeSvg">
        <polyline id="routeLine" points=""></polyline>
      </svg>
    </div>
  </div>

  <div class="overlay-controls" id="overlayControls">
    <label><input type="radio" name="overlay" value="none" checked> No overlay</label>
    <label><input type="radio" name="overlay" value="clouds"> Clouds ‚òÅÔ∏è</label>
    <label><input type="radio" name="overlay" value="precipitation"> Precipitation üåßÔ∏è</label>
    <label><input type="radio" name="overlay" value="wind"> Wind üí®</label>
    <label><input type="radio" name="overlay" value="temp"> Temperature üå°Ô∏è</label>
    <label><input type="radio" name="overlay" value="swell"> Swell üåä</label>
    <label><input type="radio" name="overlay" value="windwaves"> Wind waves üåäüí®</label>
  </div>

  <!-- Top controls -->
  <div class="top-buttons">
    <button class="mode-btn" id="duskBtn" title="Dusk Mode">üåÜ</button>
    <button class="mode-btn" id="dayBtn" title="Day Mode">üå§Ô∏è</button>
    <button class="mode-btn" id="zoomInBtn" title="Zoom In">Ôºã</button>
    <button class="mode-btn" id="zoomOutBtn" title="Zoom Out">Ôºç</button>
    <input id="placeInput" placeholder="Type place name">
    <button id="placeGo">Go</button>
    <input id="latLonInput" placeholder="Deg Min N/S, Deg Min E/W">
    <button id="latLonGo">Go</button>
    <div id="cursorLatLon">‚Äî</div>

    <button class="mode-btn" id="toggleForecastBtn" title="Show/Hide Forecast">üìä Show forecast</button>

    <label class="top-waypoints-toggle">
      <input type="checkbox" id="enableWaypointsTop">
      Enable waypoint drops
    </label>

    <button class="mode-btn" id="homeBtn" title="Home" style="margin-left:auto;">üè† Home</button>
  </div>

  <!-- Route details console (below main bar) -->
  <div class="route-details" id="routeDetails">
    <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;font-size:0.9em;">
      <span style="font-weight:600;">Route console</span>
      <label>Speed (knots):
        <input type="number" id="vesselSpeed" min="0" step="0.1" value="12" style="width:70px;">
      </label>
      <label>Departure UTC:
        <input type="datetime-local" id="departureUtc" style="width:170px;">
      </label>
      <button id="departureGoBtn" style="padding:4px 8px;border-radius:6px;border:1px solid #8882;background:#1f2937;color:#f5f7ff;cursor:pointer;font-size:0.82em;">
        Go
      </button>
      <button id="routeResetBtn" style="padding:4px 8px;border-radius:6px;border:1px solid #f9737388;background:#7f1d1d;color:#fef2f2;cursor:pointer;font-size:0.82em;margin-left:4px;">
        Reset
      </button>
      <button id="routeExpandBtn" style="padding:4px 8px;border-radius:6px;border:1px solid #22c55e88;background:#14532d;color:#ecfdf5;cursor:pointer;font-size:0.82em;margin-left:4px;">
        Expand
      </button>
    </div>
    <table>
      <thead>
        <tr>
          <th>#</th>
          <th>Lat</th>
          <th>Lon</th>
          <th>Dist Œî (nm)</th>
          <th>ETA (UTC)</th>
          <th>Temp</th>
          <th>Wind</th>
          <th>Press</th>
          <th>Hum</th>
          <th>Weather</th>
          <th>Swell</th>
          <th>Wind wave</th>
        </tr>
      </thead>
      <tbody id="routeTableBody"></tbody>
    </table>
  </div>

  <div class="weather-panel" id="weatherPanel">
    <button id="closePanel" aria-label="Close">&times;</button>
    <div id="panelContent"></div>
  </div>

  <!-- 5-day forecast bar -->
  <div class="forecast-bar" id="forecastBar">
    <div class="forecast-header">
      <span>5‚Äëday forecast</span>
      <label for="forecastStep">Interval:</label>
      <select id="forecastStep">
        <option value="1">1 hr</option>
        <option value="3" selected>3 hr</option>
        <option value="6">6 hr</option>
        <option value="12">12 hr</option>
        <option value="18">18 hr</option>
        <option value="24">24 hr</option>
        <option value="48">48 hr</option>
        <option value="72">72 hr</option>
        <option value="96">96 hr</option>
      </select>
      <div class="forecast-header-spacer"></div>
      <button class="forecast-hide-btn" id="hideForecastBtn" title="Hide forecast">‚¨á</button>
    </div>
    <div class="forecast-scroll" id="forecastItems"></div>
  </div>
</div>

<script>
const apikey = "5eeba413966ed394db4d2df220015db4";
const tilesWrap = document.getElementById("tilesWrap");
let viewWidth = window.innerWidth;

let lastForecastData = null;
let lastMarineForecast = null;

const forecastStepSelect = document.getElementById("forecastStep");
const forecastItems = document.getElementById("forecastItems");
const forecastBar = document.getElementById("forecastBar");
const toggleForecastBtn = document.getElementById("toggleForecastBtn");
const hideForecastBtn = document.getElementById("hideForecastBtn");

/* Waypoint / route console elements */
const enableWaypointsTop = document.getElementById("enableWaypointsTop");
const vesselSpeedInput = document.getElementById("vesselSpeed");
const departureUtcInput = document.getElementById("departureUtc");
const routeDetailsDiv = document.getElementById("routeDetails");
const routeTableBody = document.getElementById("routeTableBody");
const departureGoBtn = document.getElementById("departureGoBtn");
const routeResetBtn = document.getElementById("routeResetBtn");
const routeExpandBtn = document.getElementById("routeExpandBtn");

/* SVG for route polyline */
const routeSvg = document.getElementById("routeSvg");
const routeLine = document.getElementById("routeLine");

/* Keep up to 15 markers */
let markers = []; // {lat, lon, el}

/* Map tiles init */
function addTileImgs(layerClass) {
  for(let i=0; i<3; ++i) {
    let img = document.createElement("img");
    img.className = layerClass;
    img.style.left = (i*100) + 'vw';
    img.style.top = '0';
    if (layerClass=="world-map") {
      img.src="https://upload.wikimedia.org/wikipedia/commons/8/80/World_map_-_low_resolution.svg";
      img.draggable = false;
      tilesWrap.appendChild(img);
    } else {
      img.src = '';
      img.draggable = false;
      img.dataset.tileIdx = i;
      img.style.zIndex = 50;
      img.classList.add('overlay-img','hidden');
      tilesWrap.appendChild(img);
    }
  }
}
addTileImgs("world-map");
addTileImgs("overlay-img clouds");
addTileImgs("overlay-img precipitation");
addTileImgs("overlay-img wind");
addTileImgs("overlay-img temp");
addTileImgs("overlay-img swell");
addTileImgs("overlay-img windwaves");

window.addEventListener("resize", ()=>{ viewWidth=window.innerWidth; updateMap(); updateOverlayImgs(); });

/* Overlay types */
const overlayTypes = {
  'clouds':'clouds_new',
  'precipitation':'precipitation_new',
  'wind':'wind_new',
  'temp':'temp_new',
  'swell':'swell_layer_id',
  'windwaves':'windwaves_layer_id'
};

const overlayControls = document.getElementById("overlayControls");
let overlayState = "none";

overlayControls.addEventListener("change",e=>{
  overlayState=e.target.value;
  updateOverlayImgs();
});

function updateOverlayImgs() {
  ["clouds","precipitation","wind","temp","swell","windwaves"].forEach(type=>{
    Array.from(tilesWrap.querySelectorAll(`.overlay-img.${type}`)).forEach((img,i)=>{
        if (overlayState!==type) img.classList.add("hidden");
        else {
          img.classList.remove("hidden");
          const layerName = overlayTypes[type];
          img.src = `https://tile.openweathermap.org/map/${layerName}/0/${i}/0.png?appid=${apikey}`;
        }
    });
  });
  if (overlayState==="none") {
    Array.from(tilesWrap.querySelectorAll(`.overlay-img`)).forEach(img=>img.classList.add("hidden"));
  }
}
updateOverlayImgs();

/* Map pan and click separation */
let mapZoom = 1;
let panOffset = 0, dragStart = 0, panY = 0;
let isDragging = false;
let downX = 0, downY = 0;
const CLICK_THRESHOLD = 8;

function updateMap() {
    tilesWrap.style.transform = `scale(${mapZoom}) translateX(${(panOffset - viewWidth)/mapZoom}px) translateY(${panY/mapZoom}px)`;
    updateOverlayImgs();
    updateRouteLine();
}

/* Recenter map to default (no pan) */
function recenterMap() {
  panOffset = 0;
  panY = 0;
  updateMap();
}

function beginDrag(x, y){
    isDragging = true;
    dragStart = x;
    downX = x;
    downY = y;
    tilesWrap.classList.add('dragging');
}
function moveDrag(x){
    panOffset += x - dragStart;
    dragStart = x;
    updateMap();
}
function endDrag(e){
    viewWidth = window.innerWidth;
    panOffset = ((panOffset % viewWidth) + viewWidth) % viewWidth;
    updateMap();
    isDragging = false;
    tilesWrap.classList.remove('dragging');

    const upX = e.clientX || (e.changedTouches && e.changedTouches[0].clientX) || 0;
    const upY = e.clientY || (e.changedTouches && e.changedTouches[0].clientY) || 0;
    const dx = Math.abs(upX - downX);
    const dy = Math.abs(upY - downY);
    if (dx < CLICK_THRESHOLD && dy < CLICK_THRESHOLD) {
        if (enableWaypointsTop.checked) {
          handleMapClick(upX, upY);
        } else {
          handleMapClickSingle(upX, upY);
        }
    }
}

/* Mouse events */
tilesWrap.addEventListener('mousedown', function(e){
  if (e.button===0 && !e.target.closest('.top-buttons')) {
    beginDrag(e.clientX, e.clientY);
  }
});
window.addEventListener('mousemove', function(e){ if (isDragging) moveDrag(e.clientX); });
window.addEventListener('mouseup', function(e){ if (isDragging) endDrag(e); });

/* Touch events */
tilesWrap.addEventListener('touchstart', function(e){
  if (!e.target.closest('.top-buttons') && e.touches.length === 1) {
    beginDrag(e.touches[0].clientX, e.touches[0].clientY);
  }}, {passive:false});
tilesWrap.addEventListener('touchmove', function(e){
  if (isDragging && e.touches.length === 1) {
    e.preventDefault();
    moveDrag(e.touches[0].clientX);
  }}, {passive:false});
tilesWrap.addEventListener('touchend', function(e){
  if (isDragging) endDrag(e.changedTouches[0]);
}, {passive:false});

/* Zoom buttons */
document.getElementById("zoomInBtn").onclick = () => { if (mapZoom < 4) { mapZoom += 0.25; updateMap(); } };
document.getElementById("zoomOutBtn").onclick = () => { if (mapZoom > 1) { mapZoom -= 0.25; updateMap(); } };

/* Mode toggle */
const duskBtn = document.getElementById("duskBtn"),
      dayBtn  = document.getElementById("dayBtn");

function setMode(mode) {
    document.body.classList.remove("dusk-mode", "day-mode");
    if (mode === "dusk") document.body.classList.add("dusk-mode");
    else document.body.classList.add("day-mode");
    localStorage.setItem("mode",mode);
}
duskBtn.onclick = ()=>setMode("dusk");
dayBtn.onclick  = ()=>setMode("day");
(function(){ let mode = localStorage.getItem("mode"); setMode(mode === "day" ? "day" : "dusk"); })();

const weatherPanel = document.getElementById("weatherPanel");
const panelContent = document.getElementById("panelContent");
const closePanel = document.getElementById("closePanel");
closePanel.onclick = () => weatherPanel.classList.remove("active");

/* Waypoint toggle shows/hides route details and recentres map */
enableWaypointsTop.addEventListener("change", () => {
  if (enableWaypointsTop.checked) {
    routeDetailsDiv.style.display = "block";
    recenterMap();  // recentre when enabling waypoints
  } else {
    routeDetailsDiv.style.display = "none";
  }
});

/* Info tab: current + marine wave data + pressure, wind in kt (waves in m only) */
function showWeatherPanel(data, lat, lon, marine) {
    const name = data?.name || '';
    const weather = data?.weather?.[0];
    let icon = weather?.icon ? `<img src="https://openweathermap.org/img/wn/${weather.icon}@2x.png" style="width:40px;height:40px;vertical-align:middle;">` : '';
    const desc = weather?.description || '';
    const temp = data?.main?.temp !== undefined ? Math.round(data.main.temp)+"¬∞C" : '‚Äî';
    const wind = data?.wind?.speed !== undefined ? (data.wind.speed * 1.943844).toFixed(1) + " kt" : '‚Äî';
    const hum  = data?.main?.humidity !== undefined ? (data.main.humidity + "%") : '‚Äî';
    const pres = data?.main?.pressure !== undefined ? (data.main.pressure + " mb") : "‚Äî";
    let coordsInfo = lat && lon ? `<div style="font-size:.82em;opacity:.78">${(+lat).toFixed(4)}, ${(lon).toFixed(4)}</div>` : '';

    let totalWave = "‚Äî", swellWave = "‚Äî", windWave = "‚Äî";
    if (marine && marine.hourly) {
        const h = marine.hourly;
        if (Array.isArray(h.wave_height) && h.wave_height.length) totalWave = h.wave_height[0].toFixed(1) + " m";
        if (Array.isArray(h.swell_wave_height) && h.swell_wave_height.length) swellWave = h.swell_wave_height[0].toFixed(1) + " m";
        if (Array.isArray(h.wind_wave_height) && h.wind_wave_height.length) windWave = h.wind_wave_height[0].toFixed(1) + " m";
    }

    panelContent.innerHTML = `
      <b style="font-size:1.1em">${icon}${name?name:"Lat/Lon"}</b> ${coordsInfo}
      <div>${desc}</div>
      <div>üå° Temp: <b>${temp}</b></div>
      <div>üíß Humidity: <b>${hum}</b></div>
      <div>üå¨ Wind: <b>${wind}</b></div>
      <div>üß≠ Pressure: <b>${pres}</b></div>
      <hr style="border:none;border-top:1px solid #0003;margin:6px 0;">
      <div style="font-weight:bold;margin-bottom:3px;">üåä Wave snapshot</div>
      <div>Total waves: <b>${totalWave}</b></div>
      <div>Swell height: <b>${swellWave}</b></div>
      <div>Wind wave height: <b>${windWave}</b></div>
    `;
    weatherPanel.classList.add("active");
}

/* Marine time alignment for forecast */
function getMarineAtTime(targetTimeMs) {
    if (!lastMarineForecast || !lastMarineForecast.hourly || !Array.isArray(lastMarineForecast.hourly.time)) {
        return { wave_height: null, swell_wave_height: null, wind_wave_height: null };
    }
    const times = lastMarineForecast.hourly.time;
    const wh = lastMarineForecast.hourly.wave_height || [];
    const swh = lastMarineForecast.hourly.swell_wave_height || [];
    const wwh = lastMarineForecast.hourly.wind_wave_height || [];

    let bestIdx = -1;
    let bestDiff = Infinity;
    for (let i = 0; i < times.length; i++) {
        const tMs = Date.parse(times[i]);
        const diff = Math.abs(tMs - targetTimeMs);
        if (diff < bestDiff) {
            bestDiff = diff;
            bestIdx = i;
        }
    }
    if (bestIdx === -1) return { wave_height: null, swell_wave_height: null, wind_wave_height: null };

    return {
        wave_height: wh[bestIdx] ?? null,
        swell_wave_height: swh[bestIdx] ?? null,
        wind_wave_height: wwh[bestIdx] ?? null
    };
}

/* Find nearest forecast entry to a given UTC time */
function getForecastAtTime(targetTimeMs) {
    if (!lastForecastData || !Array.isArray(lastForecastData.list)) return null;
    let best = null;
    let bestDiff = Infinity;
    for (const entry of lastForecastData.list) {
        const tMs = entry.dt * 1000;
        const diff = Math.abs(tMs - targetTimeMs);
        if (diff < bestDiff) {
            bestDiff = diff;
            best = entry;
        }
    }
    return best;
}

/* Forecast bar rendering (wind in knots, waves in m/ft) */
function renderForecastBar() {
    forecastItems.innerHTML = "";
    if (!lastForecastData || !Array.isArray(lastForecastData.list)) return;

    const stepHours = parseInt(forecastStepSelect.value, 10);
    const list = lastForecastData.list;

    const baseStep = 3;
    const indicesStep = Math.max(1, Math.round(stepHours / baseStep));

    for (let i = 0; i < list.length; i += indicesStep) {
        const entry = list[i];
        const dtMs = entry.dt * 1000;
        const d = new Date(dtMs);
        const hour = d.getUTCHours().toString().padStart(2,"0");
        const day = d.getUTCDate().toString().padStart(2,"0");
        const month = (d.getUTCMonth()+1).toString().padStart(2,"0");

        const temp = entry.main && entry.main.temp !== undefined ? Math.round(entry.main.temp) + "¬∞C" : "‚Äî";
        let wind = "‚Äî";
        if (entry.wind && entry.wind.speed !== undefined) {
          const wms = entry.wind.speed;
          const wkn = wms * 1.943844;
          wind = wkn.toFixed(1) + " kt";
        }
        const hum  = entry.main && entry.main.humidity !== undefined ? entry.main.humidity + "%" : "‚Äî";
        const pres = entry.main && entry.main.pressure !== undefined ? entry.main.pressure + " mb" : "‚Äî";

        const rain = entry.rain && entry.rain["3h"] !== undefined ? entry.rain["3h"] : 0;
        const snow = entry.snow && entry.snow["3h"] !== undefined ? entry.snow["3h"] : 0;
        const precipTotal = rain + snow;
        const precipText = precipTotal > 0 ? precipTotal.toFixed(1) + " mm" : "0 mm";

        const weather = entry.weather && entry.weather[0];
        const desc = weather?.description || "";
        const iconCode = weather?.icon;
        const iconUrl = iconCode ? `https://openweathermap.org/img/wn/${iconCode}.png` : "";

        const marine = getMarineAtTime(dtMs);
        let swell = "‚Äî";
        let windWave = "‚Äî";
        if (marine.swell_wave_height != null) {
          const mVal = marine.swell_wave_height;
          const ftVal = mVal * 3.28084;
          swell = mVal.toFixed(1) + " m / " + ftVal.toFixed(1) + " ft";
        }
        if (marine.wind_wave_height != null) {
          const mVal = marine.wind_wave_height;
          const ftVal = mVal * 3.28084;
          windWave = mVal.toFixed(1) + " m / " + ftVal.toFixed(1) + " ft";
        }

        const item = document.createElement("div");
        item.className = "forecast-item";
        item.innerHTML = `
          <div class="forecast-item-time">${day}/${month} ${hour}:00Z</div>
          <div class="forecast-item-temp">${temp}</div>
          <div class="forecast-item-line">
            ${iconUrl ? `<img src="${iconUrl}" alt="" class="forecast-item-icon">` : ""}<span>${desc}</span>
          </div>
          <div class="forecast-item-line">Wind: ${wind}</div>
          <div class="forecast-item-line">Hum: ${hum}</div>
          <div class="forecast-item-line">Press: ${pres}</div>
          <div class="forecast-item-line">Precip: ${precipText}</div>
          <div class="forecast-item-line">Swell: ${swell}</div>
          <div class="forecast-item-line">Wind wave: ${windWave}</div>
        `;
        forecastItems.appendChild(item);
    }
}
forecastStepSelect.addEventListener("change", renderForecastBar);

/* Toggle forecast bar visibility */
function toggleForecast() {
    if (!forecastBar.style.display || forecastBar.style.display === "none") {
        forecastBar.style.display = "block";
    } else {
        forecastBar.style.display = "none";
    }
}
toggleForecastBtn.onclick = toggleForecast;
hideForecastBtn.onclick = toggleForecast;

/* Haversine distance in nautical miles */
function distanceNm(lat1, lon1, lat2, lon2) {
  const R = 6371e3;
  const toRad = x => x * Math.PI / 180;
  const œÜ1 = toRad(lat1);
  const œÜ2 = toRad(lat2);
  const ŒîœÜ = toRad(lat2 - lat1);
  const ŒîŒª = toRad(lon2 - lon1);
  const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
            Math.cos(œÜ1) * Math.cos(œÜ2) *
            Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  const dMeters = R * c;
  const dNm = dMeters / 1852;
  return dNm;
}

/* Build route table from markers (Lat/Lon editable, total distance & avg waves) */
function updateRouteTable() {
  routeTableBody.innerHTML = "";
  if (!markers.length || !lastForecastData) return;

  const speedKnots = parseFloat(vesselSpeedInput.value) || 0;
  const depStr = departureUtcInput.value;
  if (!speedKnots || !depStr) return;

  const depTime = new Date(depStr + "Z");
  let cumulativeHours = 0;
  let totalDistNm = 0;

  let swellSum = 0;
  let swellCount = 0;
  let windWaveSum = 0;
  let windWaveCount = 0;

  for (let i = 0; i < markers.length; i++) {
    const m = markers[i];
    let distDelta = 0;
    if (i > 0) {
      const prev = markers[i-1];
      distDelta = distanceNm(prev.lat, prev.lon, m.lat, m.lon);
      totalDistNm += distDelta;
      const hoursSeg = distDelta / speedKnots;
      cumulativeHours += hoursSeg;
    }
    const etaMs = depTime.getTime() + cumulativeHours * 3600 * 1000;
    const eta = new Date(etaMs);

    const etaStr = `${eta.getUTCDate().toString().padStart(2,"0")}.` +
                   `${(eta.getUTCMonth()+1).toString().padStart(2,"0")}.` +
                   `${eta.getUTCFullYear()} ` +
                   `${eta.getUTCHours().toString().padStart(2,"0")}` +
                   `${eta.getUTCMinutes().toString().padStart(2,"0")}Z`;

    const fcEntry = getForecastAtTime(etaMs);
    let temp="‚Äî", wind="‚Äî", pres="‚Äî", hum="‚Äî", desc="", swell="‚Äî", windWave="‚Äî";
    if (fcEntry) {
      if (fcEntry.main) {
        if (fcEntry.main.temp !== undefined) temp = Math.round(fcEntry.main.temp)+"¬∞C";
        if (fcEntry.main.humidity !== undefined) hum = fcEntry.main.humidity+"%";
        if (fcEntry.main.pressure !== undefined) pres = fcEntry.main.pressure+" mb";
      }
      if (fcEntry.wind && fcEntry.wind.speed !== undefined) {
        const wms = fcEntry.wind.speed;
        const wkn = wms * 1.943844;
        wind = wkn.toFixed(1)+" kt";
      }
      if (fcEntry.weather && fcEntry.weather[0]) {
        desc = fcEntry.weather[0].description || "";
      }
      const marine = getMarineAtTime(etaMs);
      if (marine.swell_wave_height != null) {
        const mVal = marine.swell_wave_height;
        const ftVal = mVal * 3.28084;
        swell = mVal.toFixed(1)+" m / "+ftVal.toFixed(1)+" ft";
        swellSum += mVal;
        swellCount++;
      }
      if (marine.wind_wave_height != null) {
        const mVal = marine.wind_wave_height;
        const ftVal = mVal * 3.28084;
        windWave = mVal.toFixed(1)+" m / "+ftVal.toFixed(1)+" ft";
        windWaveSum += mVal;
        windWaveCount++;
      }
    }

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${i+1}</td>
      <td><input class="wp-lat-input" data-index="${i}" value="${m.lat.toFixed(3)}" style="width:70px;"></td>
      <td><input class="wp-lon-input" data-index="${i}" value="${m.lon.toFixed(3)}" style="width:80px;"></td>
      <td>${distDelta ? distDelta.toFixed(1) : "0.0"}</td>
      <td>${etaStr}</td>
      <td>${temp}</td>
      <td>${wind}</td>
      <td>${pres}</td>
      <td>${hum}</td>
      <td>${desc}</td>
      <td>${swell}</td>
      <td>${windWave}</td>
    `;
    routeTableBody.appendChild(tr);
  }

  const avgSwellM = swellCount ? swellSum / swellCount : 0;
  const avgWindWaveM = windWaveCount ? windWaveSum / windWaveCount : 0;
  const avgSwell = swellCount ? avgSwellM.toFixed(1)+" m / "+(avgSwellM*3.28084).toFixed(1)+" ft" : "‚Äî";
  const avgWindWave = windWaveCount ? avgWindWaveM.toFixed(1)+" m / "+(avgWindWaveM*3.28084).toFixed(1)+" ft" : "‚Äî";

  const totalRow = document.createElement("tr");
  totalRow.style.fontWeight = "600";
  totalRow.innerHTML = `
    <td colspan="3" style="text-align:right;">Total distance:</td>
    <td>${totalDistNm.toFixed(1)}</td>
    <td colspan="3" style="text-align:right;">Avg swell:</td>
    <td colspan="2">${avgSwell}</td>
    <td style="text-align:right;">Avg wind wave:</td>
    <td colspan="2">${avgWindWave}</td>
  `;
  routeTableBody.appendChild(totalRow);
}

/* Go button: recompute route table for new departure time/speed */
departureGoBtn.addEventListener("click", () => {
  updateRouteTable();
});

/* Reset button: clear markers, line, and table */
routeResetBtn.addEventListener("click", () => {
  markers.forEach(m => {
    if (m.el && m.el.parentNode) m.el.parentNode.removeChild(m.el);
  });
  markers = [];
  routeLine.setAttribute("points", "");
  routeTableBody.innerHTML = "";
});

/* Expand button: toggle full/compact console */
let consoleExpanded = false;
routeExpandBtn.addEventListener("click", () => {
  consoleExpanded = !consoleExpanded;
  if (consoleExpanded) {
    routeDetailsDiv.style.maxHeight = "60vh";  // expanded view
    routeExpandBtn.textContent = "Collapse";
  } else {
    routeDetailsDiv.style.maxHeight = "110px"; // compact (~3 rows)
    routeExpandBtn.textContent = "Expand";
  }
});

/* Handle manual edits in route table */
routeTableBody.addEventListener("change", (e) => {
  const t = e.target;
  if (!(t.classList.contains("wp-lat-input") || t.classList.contains("wp-lon-input"))) return;

  const idx = parseInt(t.dataset.index, 10);
  if (isNaN(idx) || !markers[idx]) return;

  const row = t.closest("tr");
  const latInput = row.querySelector(".wp-lat-input");
  const lonInput = row.querySelector(".wp-lon-input");
  const newLat = parseFloat(latInput.value);
  const newLon = parseFloat(lonInput.value);
  if (isNaN(newLat) || isNaN(newLon)) return;

  markers[idx].lat = newLat;
  markers[idx].lon = newLon;

  const latRad = Math.atanh(Math.sin(newLat * Math.PI / 180));
  const yPercent = (0.5 - latRad / Math.PI) * 100;
  const xPercent = ((newLon + 180) / 360) * 100;
  markers[idx].el.style.top = yPercent + "%";
  markers[idx].el.style.left = xPercent + "%";

  updateRouteLine();
  updateRouteTable();
});

/* Draw polyline through all markers */
function updateRouteLine() {
  if (!markers.length) {
    routeLine.setAttribute("points", "");
    return;
  }
  const r = tilesWrap.getBoundingClientRect();
  const w = r.width;
  const h = r.height;

  const pts = markers.map(m => {
    const xNorm = (m.lon + 180) / 360;
    const latRad = Math.atanh(Math.sin(m.lat * Math.PI / 180));
    const yNorm = 0.5 - latRad / Math.PI;
    const x = xNorm * w;
    const y = yNorm * h;
    return `${x},${y}`;
  }).join(" ");
  routeLine.setAttribute("points", pts);
}

/* Add marker (up to 15) */
function addMarker(lat, lon) {
    const marker = document.createElement("div");
    marker.className = "location-marker";
    marker.textContent = "üìç";

    const latRad = Math.atanh(Math.sin(lat * Math.PI / 180));
    const yPercent = (0.5 - latRad / Math.PI) * 100;
    const xPercent = ((lon + 180) / 360) * 100;

    marker.style.top = yPercent + "%";
    marker.style.left = xPercent + "%";

    tilesWrap.appendChild(marker);
    markers.push({lat, lon, el: marker});

    if (markers.length > 15) {
        const old = markers.shift();
        if (old.el) old.el.remove();
    }
    updateRouteLine();
    updateRouteTable();
}

/* Single marker mode (no route) */
function handleMapClickSingle(clientX, clientY){
    const r = tilesWrap.getBoundingClientRect();
    const ww = r.width;

    let xPx = clientX - r.left - panOffset;
    xPx = ((xPx % ww) + ww) % ww;

    const xNorm = xPx / ww;
    const yNorm = (clientY - r.top) / r.height;

    if (xNorm < 0 || xNorm > 1 || yNorm < 0 || yNorm > 1) return;

    const lon = xNorm * 360 - 180;
    const latRad = (0.5 - yNorm) * Math.PI;
    const lat = (180 / Math.PI) * Math.atan(Math.sinh(latRad));

    fetchWeatherAndForecast(lat, lon);
}

/* Waypoint mode click ‚Äì adds marker and uses it in route */
function handleMapClick(clientX, clientY){
    const r = tilesWrap.getBoundingClientRect();
    const ww = r.width;

    let xPx = clientX - r.left - panOffset;
    xPx = ((xPx % ww) + ww) % ww;

    const xNorm = xPx / ww;
    const yNorm = (clientY - r.top) / r.height;

    if (xNorm < 0 || xNorm > 1 || yNorm < 0 || yNorm > 1) return;

    const lon = xNorm * 360 - 180;
    const latRad = (0.5 - yNorm) * Math.PI;
    const lat = (180 / Math.PI) * Math.atan(Math.sinh(latRad));

    addMarker(lat, lon);
    fetchWeatherAndForecast(lat, lon);
}

/* Combined current + 5 day + marine. */
async function fetchWeatherAndForecast(lat, lon) {
    const weatherUrl   = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apikey}&units=metric`;
    const forecastUrl  = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${apikey}&units=metric`;
    const marineUrl    = `https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&hourly=wave_height,swell_wave_height,wind_wave_height&length=120`;

    const [weatherRes, forecastRes, marineRes] = await Promise.all([
        fetch(weatherUrl),
        fetch(forecastUrl),
        fetch(marineUrl)
    ]);

    const weatherData  = await weatherRes.json();
    const forecastData = await forecastRes.json();
    const marineData   = await marineRes.json();

    lastForecastData = forecastData;
    lastMarineForecast = marineData;

    showWeatherPanel(weatherData, lat, lon, marineData);
    renderForecastBar();
    updateRouteTable();
}

/* Place search + full forecast + marine */
document.getElementById("placeGo").onclick = handlePlaceSearch;
document.getElementById("placeInput").onkeypress = function(e){ if (e.key==="Enter") handlePlaceSearch(); };

async function handlePlaceSearch() {
    let place = document.getElementById("placeInput").value.trim();
    if (!place) return;
    let url = "https://api.openweathermap.org/data/2.5/weather?q=" + encodeURIComponent(place) + "&appid=" + apikey + "&units=metric";
    let res = await fetch(url); let data = await res.json();
    if (!data.coord) { alert("Place not found"); return; }
    const lat = data.coord.lat;
    const lon = data.coord.lon;

    if (enableWaypointsTop.checked) addMarker(lat, lon);

    const forecastUrl  = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${apikey}&units=metric`;
    const marineUrl    = `https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&hourly=wave_height,swell_wave_height,wind_wave_height&length=120`;

    const [forecastRes, marineRes] = await Promise.all([
        fetch(forecastUrl),
        fetch(marineUrl)
    ]);

    lastForecastData = await forecastRes.json();
    lastMarineForecast = await marineRes.json();

    showWeatherPanel(data, lat, lon, lastMarineForecast);
    renderForecastBar();
    updateRouteTable();
}

/* Lat/lon search + full forecast + marine */
document.getElementById("latLonGo").onclick = handleLatLonSearch;
document.getElementById("latLonInput").onkeypress = function(e){ if(e.key==="Enter") handleLatLonSearch(); };

async function handleLatLonSearch() {
    const value = document.getElementById("latLonInput").value.trim();
    const pattern = /([0-9]{1,3})[¬∞\s]*([0-9]{1,2}(?:\.\d+)?)[\'\s]*([NSns]),?\s*([0-9]{1,3})[¬∞\s]*([0-9]{1,2}(?:\.\d+)?)[\'\s]*([EWew])/;
    const match = value.match(pattern);
    if (!match) { alert("Format: 37 47.5 N, 122 25.2 W"); return; }
    let latDeg = parseFloat(match[1]), latMin = parseFloat(match[2]), latDir = match[3].toUpperCase();
    let lonDeg = parseFloat(match[4]), lonMin = parseFloat(match[5]), lonDir = match[6].toUpperCase();
    let lat = latDeg + (latMin / 60); if (latDir === "S") lat = -lat;
    let lon = lonDeg + (lonMin / 60); if (lonDir === "W") lon = -lon;

    if (enableWaypointsTop.checked) addMarker(lat, lon);

    const weatherUrl   = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apikey}&units=metric`;
    const forecastUrl  = `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${apikey}&units=metric`;
    const marineUrl    = `https://marine-api.open-meteo.com/v1/marine?latitude=${lat}&longitude=${lon}&hourly=wave_height,swell_wave_height,wind_wave_height&length=120`;

    const [weatherRes, forecastRes, marineRes] = await Promise.all([
        fetch(weatherUrl),
        fetch(forecastUrl),
        fetch(marineUrl)
    ]);

    const weatherData  = await weatherRes.json();
    const forecastData = await forecastRes.json();
    const marineData   = await marineRes.json();

    lastForecastData = forecastData;
    lastMarineForecast = marineData;

    showWeatherPanel(weatherData, lat, lon, marineData);
    renderForecastBar();
    updateRouteTable();
}

/* Cursor lat/lon readout */
const cursorLatLon = document.getElementById("cursorLatLon");
tilesWrap.addEventListener("mousemove", function(e){
    const r = tilesWrap.getBoundingClientRect();
    const ww = r.width;
    let xPx = e.clientX - r.left - panOffset;
    xPx = ((xPx % ww) + ww) % ww;

    const x = xPx / ww;
    const y = (e.clientY - r.top) / r.height;
    if (x < 0 || x > 1 || y < 0 || y > 1) { cursorLatLon.textContent = '‚Äî'; return; }
    const lon = (x * 360 - 180).toFixed(2);
    const latRad = (0.5 - y) * Math.PI;
    const lat = ((180 / Math.PI) * Math.atan(Math.sinh(latRad))).toFixed(2);
    cursorLatLon.textContent = lat + "," + lon;
});
tilesWrap.addEventListener("mouseleave", ()=> cursorLatLon.textContent = "‚Äî");

// Home button action
document.getElementById("homeBtn").onclick = () => {
    window.location.href = "index.html";
};
</script>
</body>
</html>
